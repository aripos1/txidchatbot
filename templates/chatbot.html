{% extends "base.html" %}

{% block title %}ë¸”ë¡ì²´ì¸ AI ì±—ë´‡{% endblock %}

{% block meta_description %}ë¸”ë¡ì²´ì¸ê³¼ ë¹—ì¸ ê±°ë˜ì†Œ ì •ë³´ë¥¼ ì œê³µí•˜ëŠ” AI ì±—ë´‡. íŠ¸ëœì­ì…˜ ì¡°íšŒ, FAQ ê²€ìƒ‰, ë¸”ë¡ì²´ì¸ ê´€ë ¨ ì§ˆë¬¸ì— ë‹µë³€í•©ë‹ˆë‹¤.{% endblock %}

{% block og_title %}ë¸”ë¡ì²´ì¸ AI ì±—ë´‡ - Multi Chain Explorer{% endblock %}
{% block og_description %}ë¸”ë¡ì²´ì¸ê³¼ ë¹—ì¸ ê±°ë˜ì†Œ ì •ë³´ë¥¼ ì œê³µí•˜ëŠ” AI ì±—ë´‡{% endblock %}
{% block og_url %}https://txid.shop/chat{% endblock %}

{% block styles %}
<link rel="stylesheet" href="/static/css/chatbot.css">
<style>
/* ì¶”ê°€ ì±—ë´‡ ì „ìš© ìŠ¤íƒ€ì¼ */
.thinking-process {
    background: var(--bg-tertiary);
    border: 1px solid var(--border-color-light);
    border-radius: var(--radius-md);
    padding: var(--space-md);
    margin: var(--space-md) 0;
    font-size: var(--font-size-sm);
    color: var(--text-secondary);
    cursor: pointer;
    transition: all var(--transition-base);
}

.thinking-process.collapsed .thinking-content {
    display: none;
}

.thinking-process.expanded .thinking-content {
    display: block;
}

.thinking-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: var(--space-sm);
}

.thinking-title {
    font-weight: var(--font-weight-semibold);
    color: var(--text-primary);
}

.thinking-toggle {
    font-size: var(--font-size-sm);
    color: var(--text-tertiary);
    transition: transform var(--transition-base);
}

.thinking-step {
    margin-bottom: var(--space-md);
    padding-bottom: var(--space-md);
    border-bottom: 1px solid var(--border-color-light);
}

.thinking-step:last-child {
    margin-bottom: 0;
    padding-bottom: 0;
    border-bottom: none;
}

.thinking-step-title {
    font-weight: var(--font-weight-semibold);
    color: var(--color-primary);
    margin-bottom: var(--space-xs);
}

.thinking-step-content {
    color: var(--text-secondary);
    font-size: var(--font-size-sm);
    line-height: var(--line-height-relaxed);
}

.empty-state {
    text-align: center;
    padding: var(--space-3xl) var(--space-lg);
    color: var(--text-secondary);
}

.empty-state h2 {
    font-size: var(--font-size-2xl);
    font-weight: var(--font-weight-bold);
    color: var(--text-primary);
    margin-bottom: var(--space-md);
}

.empty-state p {
    font-size: var(--font-size-base);
    line-height: var(--line-height-relaxed);
}

.send-btn {
    padding: var(--space-md) var(--space-xl);
    background: linear-gradient(135deg, var(--color-primary) 0%, var(--color-primary-dark) 100%);
    color: var(--text-inverse);
    border: none;
    border-radius: var(--radius-lg);
    font-size: var(--font-size-base);
    font-weight: var(--font-weight-semibold);
    cursor: pointer;
    transition: all var(--transition-base);
    display: flex;
    align-items: center;
    gap: var(--space-sm);
    white-space: nowrap;
    box-shadow: var(--shadow-sm);
}

.send-btn:hover:not(:disabled) {
    transform: translateY(-1px);
    box-shadow: var(--shadow-md);
}

.send-btn:disabled {
    opacity: 0.6;
    cursor: not-allowed;
}

@media (max-width: 1024px) {
    .chatbot-layout {
        grid-template-columns: 1fr;
    }
    
    .chatbot-sidebar {
        order: -1;
        position: relative;
        top: 0;
    }
}
</style>
{% endblock %}

{% block content %}
<div class="chatbot-wrapper">
    <!-- AdSense: í—¤ë” ì•„ë˜ ë°°ë„ˆ ê´‘ê³  (728x90) -->
    <div class="adsense-container adsense-header-banner">
        <!-- Google AdSense ê´‘ê³  ì½”ë“œë¥¼ ì—¬ê¸°ì— ì‚½ì…í•˜ì„¸ìš” -->
    </div>

    <!-- 2-Column Layout (ì±—ë´‡ + ì‚¬ì´ë“œë°”) -->
    <div class="chatbot-layout">
        <!-- Main Chatbot Area -->
        <div class="chatbot-main">
            <div class="chat-container card fade-in">
                <div class="chat-header">
                    <h1>ğŸ¤– ë¸”ë¡ì²´ì¸ ì±—ë´‡</h1>
                    <button class="clear-btn" onclick="clearChat()">ëŒ€í™” ê¸°ë¡ ì‚­ì œ</button>
                </div>
                
                <div class="chat-messages" id="chatMessages">
                    <div class="empty-state">
                        <h2>ì•ˆë…•í•˜ì„¸ìš”! ğŸ‘‹</h2>
                        <p>ë¸”ë¡ì²´ì¸ê³¼ ë¹—ì¸ ê±°ë˜ì†Œì— ê´€ë ¨ëœ ì§ˆë¬¸ì„ í•´ì£¼ì„¸ìš”.</p>
                        <p style="margin-top: var(--space-md); font-size: var(--font-size-sm);">
                            íŠ¸ëœì­ì…˜ ì¡°íšŒ, FAQ ê²€ìƒ‰, ë¸”ë¡ì²´ì¸ ì •ë³´ ë“± ë¬´ì—‡ì´ë“  ë¬¼ì–´ë³´ì„¸ìš”.
                        </p>
                    </div>
                </div>
                
                <div class="chat-input-container">
                    <form class="chat-input-form" onsubmit="sendMessage(event)">
                        <input 
                            type="text" 
                            class="chat-input" 
                            id="messageInput" 
                            placeholder="ë©”ì‹œì§€ë¥¼ ì…ë ¥í•˜ì„¸ìš”..."
                            autocomplete="off"
                        >
                        <button type="submit" class="send-btn" id="sendBtn">ì „ì†¡</button>
                    </form>
                </div>
            </div>

            <!-- AdSense: ì±—ë´‡ ì•„ë˜ ì¸ë¼ì¸ ë°°ë„ˆ ê´‘ê³  -->
            <div class="adsense-container adsense-inline-banner" style="margin-top: var(--space-xl);">
                <!-- Google AdSense ê´‘ê³  ì½”ë“œë¥¼ ì—¬ê¸°ì— ì‚½ì…í•˜ì„¸ìš” -->
            </div>
        </div>

        <!-- Sidebar -->
        <aside class="chatbot-sidebar">
            <!-- Quick Links Card -->
            <div class="card fade-in">
                <h3 class="section-title" style="margin-bottom: var(--space-md); padding-bottom: var(--space-sm); border-bottom: 2px solid var(--border-color-light);">
                    ë¹ ë¥¸ ë§í¬
                </h3>
                <nav style="display: flex; flex-direction: column; gap: var(--space-sm);">
                    <a href="/" class="btn btn-secondary" style="justify-content: flex-start;">
                        <span>ğŸ”</span>
                        <span>íŠ¸ëœì­ì…˜ ì¡°íšŒ</span>
                    </a>
                    <a href="https://coinmarketcap.com/ko/" target="_blank" rel="noopener noreferrer" class="btn btn-secondary" style="justify-content: flex-start;">
                        <span>ğŸ“Š</span>
                        <span>CoinMarketCap</span>
                    </a>
                </nav>
            </div>

            <!-- AdSense: ì‚¬ì´ë“œë°” ìƒë‹¨ ì‚¬ê°í˜• ê´‘ê³  (300x250) -->
            <div class="adsense-container adsense-sidebar">
                <!-- Google AdSense ê´‘ê³  ì½”ë“œë¥¼ ì—¬ê¸°ì— ì‚½ì…í•˜ì„¸ìš” -->
                <!-- ë°ìŠ¤í¬í†±: 300x250 ë˜ëŠ” 300x600 -->
            </div>

            <!-- AdSense: ì‚¬ì´ë“œë°” ì¤‘ê°„ ì‚¬ê°í˜• ê´‘ê³  (300x250) -->
            <div class="adsense-container adsense-sidebar adsense-vertical">
                <!-- Google AdSense ê´‘ê³  ì½”ë“œë¥¼ ì—¬ê¸°ì— ì‚½ì…í•˜ì„¸ìš” -->
                <!-- ë°ìŠ¤í¬í†±: 300x600 -->
            </div>
        </aside>
    </div>

    <!-- AdSense: í‘¸í„° ìœ„ ë°°ë„ˆ ê´‘ê³  -->
    <div class="adsense-container adsense-inline-banner" style="margin-top: var(--space-3xl);">
        <!-- Google AdSense ê´‘ê³  ì½”ë“œë¥¼ ì—¬ê¸°ì— ì‚½ì…í•˜ì„¸ìš” -->
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
// ê¸°ì¡´ chatbot.htmlì˜ ëª¨ë“  JavaScript ì½”ë“œë¥¼ ì—¬ê¸°ì— í¬í•¨
// ë…¸ë“œ í‘œì‹œ ì´ë¦„ ë§¤í•‘ (ê³µí†µ)
const NODE_DISPLAY_NAMES = {
    "router": "ğŸ”€ ë¼ìš°íŒ… ì¤‘...",
    "simple_chat_specialist": "ğŸ’¬ ì‘ë‹µ ìƒì„± ì¤‘...",
    "faq_specialist": "ğŸ“š FAQ ê²€ìƒ‰ ì¤‘...",
    "transaction_specialist": "ğŸ” íŠ¸ëœì­ì…˜ ì¡°íšŒ ì¤‘...",
    "planner": "ğŸ“‹ ê²€ìƒ‰ ê³„íš ì¤‘...",
    "researcher": "ğŸ” ì›¹ ê²€ìƒ‰ ì¤‘...",
    "grader": "ğŸ“Š ê²°ê³¼ í‰ê°€ ì¤‘...",
    "writer": "âœï¸ ì‘ë‹µ ì‘ì„± ì¤‘...",
    "intent_clarifier": "ğŸ¤” ì˜ë„ í™•ì¸ ì¤‘...",
    "save_response": "ğŸ’¾ ì €ì¥ ì¤‘..."
};

// ë…¸ë“œ ì´ë¦„ì„ "ìƒê°í•˜ëŠ” ê³¼ì •" ì œëª©ìœ¼ë¡œ ë³€í™˜
function getNodeStepTitle(nodeName, displayName) {
    const nodeTitleMap = {
        'router': 'ğŸ”€ ë¼ìš°íŒ…',
        'faq_specialist': 'ğŸ“š FAQ ê²€ìƒ‰',
        'transaction_specialist': 'ğŸ” íŠ¸ëœì­ì…˜ ì¡°íšŒ',
        'planner': 'ğŸ“‹ ê²€ìƒ‰ ê³„íš ìˆ˜ë¦½',
        'researcher': 'ğŸ” ì›¹ ê²€ìƒ‰',
        'grader': 'ğŸ“Š ê²°ê³¼ í‰ê°€',
        'writer': 'âœï¸ ì‘ë‹µ ì‘ì„±',
        'intent_clarifier': 'ğŸ¤” ì˜ë„ í™•ì¸',
        'save_response': 'ğŸ’¾ ì €ì¥'
    };
    
    return nodeTitleMap[nodeName] || displayName || null;
}

// "ìƒê°í•˜ëŠ” ê³¼ì •" ì œëª©ì—ì„œ ë…¸ë“œ ì´ë¦„ ì¶”ì¶œ
function getNodeNameFromStep(stepTitle) {
    const titleToNodeMap = {
        'ğŸ”€ ë¼ìš°íŒ…': 'router',
        'ğŸ“š FAQ ê²€ìƒ‰': 'faq_specialist',
        'ğŸ” íŠ¸ëœì­ì…˜ ì¡°íšŒ': 'transaction_specialist',
        'ğŸ“‹ ê²€ìƒ‰ ê³„íš ìˆ˜ë¦½': 'planner',
        'ğŸ” ì›¹ ê²€ìƒ‰': 'researcher',
        'ğŸ“Š ê²°ê³¼ í‰ê°€': 'grader',
        'âœï¸ ì‘ë‹µ ì‘ì„±': 'writer',
        'ğŸ¤” ì˜ë„ í™•ì¸': 'intent_clarifier',
        'ğŸ’¾ ì €ì¥': 'save_response'
    };
    
    return titleToNodeMap[stepTitle] || null;
}

// JSONì„ ì‚¬ìš©ì ì¹œí™”ì ì¸ "ìƒê°í•˜ëŠ” ê³¼ì •"ìœ¼ë¡œ ë³€í™˜
function parseThinkingProcess(jsonText) {
    try {
        const json = JSON.parse(jsonText);
        const steps = [];
        
        // Planner ë…¸ë“œ ì •ë³´
        if (json.search_queries || json.research_plan || json.priority) {
            steps.push({
                title: 'ğŸ“‹ ê²€ìƒ‰ ê³„íš ìˆ˜ë¦½',
                content: json.research_plan || 'ê²€ìƒ‰ ê³„íšì„ ìˆ˜ë¦½í•˜ê³  ìˆìŠµë‹ˆë‹¤.',
                queries: json.search_queries || []
            });
        }
        
        // Grader ë…¸ë“œ ì •ë³´
        if (json.score !== undefined || json.is_sufficient !== undefined || json.feedback) {
            const score = json.score || 0;
            const isSufficient = json.is_sufficient || false;
            const feedback = json.feedback || '';
            
            steps.push({
                title: `ğŸ“Š ê²°ê³¼ í‰ê°€ (ì ìˆ˜: ${(score * 100).toFixed(0)}%)`,
                content: feedback || (isSufficient ? 'ê²€ìƒ‰ ê²°ê³¼ê°€ ì¶©ë¶„í•©ë‹ˆë‹¤.' : 'ì¶”ê°€ ê²€ìƒ‰ì´ í•„ìš”í•©ë‹ˆë‹¤.'),
                score: score,
                isSufficient: isSufficient
            });
        }
        
        return steps;
    } catch (e) {
        return [];
    }
}

// "ìƒê°í•˜ëŠ” ê³¼ì •" UI ìƒì„± (ê°„ì†Œí™”)
function createThinkingProcessUI(steps) {
    // ë‚´ìš©ì´ ìˆëŠ” ë‹¨ê³„ë§Œ í•„í„°ë§
    const stepsWithContent = steps.filter(step => step.content && step.content.trim());
    
    if (stepsWithContent.length === 0) return null;
    
    const container = document.createElement('div');
    container.className = 'thinking-process collapsed';
    
    const header = document.createElement('div');
    header.className = 'thinking-header';
    header.innerHTML = `
        <div class="thinking-title">
            <span>ğŸ¤” ìƒê°í•˜ëŠ” ê³¼ì • (${stepsWithContent.length}ë‹¨ê³„)</span>
        </div>
        <span class="thinking-toggle">â–¼</span>
    `;
    
    const content = document.createElement('div');
    content.className = 'thinking-content';
    
    stepsWithContent.forEach(step => {
        const stepDiv = document.createElement('div');
        stepDiv.className = 'thinking-step';
        
        let stepHTML = `<div class="thinking-step-title">${step.title}</div>`;
        if (step.content) {
            stepHTML += `<div class="thinking-step-content">${step.content}</div>`;
        }
        
        stepDiv.innerHTML = stepHTML;
        content.appendChild(stepDiv);
    });
    
    container.appendChild(header);
    container.appendChild(content);
    
    // í† ê¸€ ê¸°ëŠ¥
    header.addEventListener('click', () => {
        if (container.classList.contains('collapsed')) {
            container.classList.remove('collapsed');
            container.classList.add('expanded');
            header.querySelector('.thinking-toggle').textContent = 'â–²';
        } else {
            container.classList.remove('expanded');
            container.classList.add('collapsed');
            header.querySelector('.thinking-toggle').textContent = 'â–¼';
        }
    });
    
    return container;
}

// ì„¸ì…˜ ID ìƒì„± (ë¸Œë¼ìš°ì € ì„¸ì…˜ë‹¹ ê³ ìœ )
let sessionId = sessionStorage.getItem('chatSessionId') || generateSessionId();
if (!sessionStorage.getItem('chatSessionId')) {
    sessionStorage.setItem('chatSessionId', sessionId);
}

function generateSessionId() {
    return 'session_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
}

// í˜ì´ì§€ ë¡œë“œ ì‹œ ëŒ€í™” ê¸°ë¡ ë¶ˆëŸ¬ì˜¤ê¸°
let isHistoryLoaded = false;

window.addEventListener('DOMContentLoaded', async () => {
    if (!isHistoryLoaded) {
        isHistoryLoaded = true;
        await loadChatHistory();
    }
});

async function loadChatHistory() {
    try {
        const messagesContainer = document.getElementById('chatMessages');
        messagesContainer.innerHTML = '';
        
        const response = await fetch(`/api/chat/history/${sessionId}`);
        const data = await response.json();
        
        if (data.history && data.history.length > 0) {
            const seenMessages = new Set();
            
            data.history.forEach(msg => {
                const messageKey = `${msg.role}:${msg.content}`;
                if (!seenMessages.has(messageKey)) {
                    seenMessages.add(messageKey);
                    addMessageToChat(msg.role, msg.content, false);
                }
            });
        }
    } catch (error) {
        console.error('ëŒ€í™” ê¸°ë¡ ë¶ˆëŸ¬ì˜¤ê¸° ì‹¤íŒ¨:', error);
    }
}

// ìŠ¤íŠ¸ë¦¬ë° ëª¨ë“œ ì„¤ì •
const USE_STREAMING = true;
let currentAbortController = null;

async function sendMessage(event) {
    event.preventDefault();
    
    const input = document.getElementById('messageInput');
    const message = input.value.trim();
    
    if (!message) return;
    
    // ì´ì „ ìš”ì²­ ì·¨ì†Œ
    if (currentAbortController) {
        currentAbortController.abort();
    }
    currentAbortController = new AbortController();
    
    // ì‚¬ìš©ì ë©”ì‹œì§€ í‘œì‹œ
    addMessageToChat('user', message);
    input.value = '';
    
    // ì…ë ¥ ë¹„í™œì„±í™”
    const sendBtn = document.getElementById('sendBtn');
    sendBtn.disabled = true;
    
    if (USE_STREAMING) {
        await sendMessageStreaming(message, sendBtn);
    } else {
        await sendMessageNormal(message, sendBtn);
    }
    
    // ì…ë ¥ í•„ë“œë¡œ í¬ì»¤ìŠ¤
    input.focus();
}

async function sendMessageStreaming(message, sendBtn) {
    const messagesContainer = document.getElementById('chatMessages');
    const messageDiv = document.createElement('div');
    messageDiv.className = 'message assistant';
    
    const bubble = document.createElement('div');
    bubble.className = 'message-bubble';
    bubble.innerHTML = '<span class="streaming-cursor">â–Š</span>';
    
    messageDiv.appendChild(bubble);
    messagesContainer.appendChild(messageDiv);
    messagesContainer.scrollTop = messagesContainer.scrollHeight;
    
    let thinkingProcessUI = null;
    let thinkingSteps = [];
    let shouldShowThinkingProcess = false;
    let currentResponseNode = null;
    let nodeSearchInfo = {};
    
    let fullContent = '';
    let hasReceivedToken = false;
    let jsonBlocks = [];
    let nodeHistory = [];
    
    // ê²€ìƒ‰ ì •ë³´ë¥¼ "ìƒê°í•˜ëŠ” ê³¼ì •" ì½˜í…ì¸ ë¡œ ë³€í™˜ (ê°„ì†Œí™”)
    function createThinkingStepContent(nodeName, nodeDisplay, searchInfo) {
        const queries = searchInfo.queries || [];
        const dbResults = searchInfo.db_results || [];
        const webResults = searchInfo.web_results || [];
        
        if (queries.length === 0 && dbResults.length === 0 && webResults.length === 0) {
            return null;
        }
        
        let contentParts = [];
        
        if (queries.length > 0) {
            const displayQueries = queries.slice(0, 2);
            const queryText = displayQueries.join(', ');
            const extraCount = queries.length - 2;
            contentParts.push(`ê²€ìƒ‰: ${queryText}${extraCount > 0 ? ` ì™¸ ${extraCount}ê°œ` : ''}`);
        }
        
        const totalResults = dbResults.length + webResults.length;
        if (totalResults > 0) {
            const resultTypes = [];
            if (dbResults.length > 0) resultTypes.push(`FAQ ${dbResults.length}ê°œ`);
            if (webResults.length > 0) resultTypes.push(`ì›¹ ${webResults.length}ê°œ`);
            contentParts.push(`ê²°ê³¼: ${resultTypes.join(', ')}`);
        }
        
        return contentParts.length > 0 ? contentParts.join(' â€¢ ') : null;
    }

    // "ìƒê°í•˜ëŠ” ê³¼ì •" ë‹¨ê³„ ì¶”ê°€ ë˜ëŠ” ì—…ë°ì´íŠ¸
    function addOrUpdateThinkingStep(nodeName, nodeDisplay, searchInfo) {
        if (!nodeName || nodeName === 'simple_chat_specialist' || nodeName === 'transaction_specialist') {
            return -1;
        }
        
        const stepTitle = getNodeStepTitle(nodeName, '');
        if (!stepTitle) {
            return -1;
        }
        
        let stepIndex = thinkingSteps.findIndex(step => {
            const stepNodeName = getNodeNameFromStep(step.title);
            return stepNodeName === nodeName;
        });
        
        if (stepIndex === -1) {
            if (!nodeHistory.some(n => n.name === nodeName)) {
                nodeHistory.push({
                    name: nodeName,
                    display: nodeDisplay || NODE_DISPLAY_NAMES[nodeName] || nodeName
                });
            }
            
            thinkingSteps.push({
                title: stepTitle,
                content: '',
                queries: [],
                searchInfo: {}
            });
            stepIndex = thinkingSteps.length - 1;
        }
        
        const content = createThinkingStepContent(nodeName, '', searchInfo);
        thinkingSteps[stepIndex].content = content;
        thinkingSteps[stepIndex].queries = searchInfo.queries || [];
        thinkingSteps[stepIndex].searchInfo = searchInfo;
        
        return stepIndex;
    }
    
    // "ìƒê°í•˜ëŠ” ê³¼ì •" UI ì—…ë°ì´íŠ¸ í•¨ìˆ˜
    function updateThinkingProcessUI() {
        if (!thinkingProcessUI) {
            thinkingProcessUI = createThinkingProcessUI(thinkingSteps);
        } else {
            const content = thinkingProcessUI.querySelector('.thinking-content');
            if (content) {
                content.innerHTML = '';
                
                const stepsWithContent = thinkingSteps.filter(step => step.content && step.content.trim());
                
                const header = thinkingProcessUI.querySelector('.thinking-header');
                if (header) {
                    const titleSpan = header.querySelector('.thinking-title span');
                    if (titleSpan) {
                        titleSpan.textContent = `ğŸ¤” ìƒê°í•˜ëŠ” ê³¼ì • (${stepsWithContent.length}ë‹¨ê³„)`;
                    }
                }
                
                stepsWithContent.forEach(step => {
                    const stepDiv = document.createElement('div');
                    stepDiv.className = 'thinking-step';
                    
                    let stepHTML = `<div class="thinking-step-title">${step.title}</div>`;
                    if (step.content) {
                        stepHTML += `<div class="thinking-step-content">${step.content}</div>`;
                    }
                    
                    stepDiv.innerHTML = stepHTML;
                    content.appendChild(stepDiv);
                });
            }
        }
    }
    
    try {
        const response = await fetch('/api/chat/stream', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                message: message,
                session_id: sessionId
            }),
            signal: currentAbortController.signal
        });
        
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const reader = response.body.getReader();
        const decoder = new TextDecoder();
        
        while (true) {
            const { done, value } = await reader.read();
            if (done) break;
            
            const chunk = decoder.decode(value);
            const lines = chunk.split('\n');
            
            for (const line of lines) {
                if (line.startsWith('data: ')) {
                    try {
                        const data = JSON.parse(line.slice(6));
                        
                        if (data.type === 'token') {
                            fullContent += data.content;
                            
                            let jsonStart = fullContent.indexOf('{');
                            const foundJsonBlocks = [];
                            
                            while (jsonStart !== -1) {
                                let braceCount = 0;
                                let jsonEnd = -1;
                                
                                for (let i = jsonStart; i < fullContent.length; i++) {
                                    if (fullContent[i] === '{') braceCount++;
                                    if (fullContent[i] === '}') braceCount--;
                                    if (braceCount === 0) {
                                        jsonEnd = i + 1;
                                        break;
                                    }
                                }
                                
                                if (jsonEnd > jsonStart) {
                                    const jsonText = fullContent.substring(jsonStart, jsonEnd);
                                    
                                    if (jsonText.includes('"search_queries"') || 
                                        jsonText.includes('"research_plan"') || 
                                        jsonText.includes('"priority"') ||
                                        jsonText.includes('"score"') || 
                                        jsonText.includes('"is_sufficient"') || 
                                        jsonText.includes('"feedback"') ||
                                        jsonText.includes('"missing_information"')) {
                                        
                                        try {
                                            const parsed = JSON.parse(jsonText);
                                            const isNew = !foundJsonBlocks.some(block => block.text === jsonText);
                                            
                                            if (isNew) {
                                                foundJsonBlocks.push({ text: jsonText, parsed: parsed });
                                                const alreadyExists = jsonBlocks.some(block => block.text === jsonText);
                                                if (!alreadyExists) {
                                                    jsonBlocks.push({ text: jsonText, parsed: parsed });
                                                    
                                                    const steps = parseThinkingProcess(jsonText);
                                                    if (steps.length > 0) {
                                                        thinkingSteps.push(...steps);
                                                        shouldShowThinkingProcess = true;
                                                        if (!thinkingProcessUI) {
                                                            thinkingProcessUI = createThinkingProcessUI(thinkingSteps);
                                                        } else {
                                                            updateThinkingProcessUI();
                                                        }
                                                    }
                                                }
                                            }
                                        } catch (e) {
                                            console.error('JSON íŒŒì‹± ì‹¤íŒ¨:', e);
                                        }
                                    }
                                    
                                    jsonStart = fullContent.indexOf('{', jsonEnd);
                                } else {
                                    break;
                                }
                            }
                            
                            let displayContent = fullContent;
                            const sortedBlocks = [...jsonBlocks].sort((a, b) => b.text.length - a.text.length);
                            sortedBlocks.forEach(jsonBlock => {
                                const escapedText = jsonBlock.text.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                                displayContent = displayContent.replace(new RegExp(escapedText, 'g'), '').trim();
                            });
                            
                            displayContent = displayContent.replace(/^\s*\{[\s\S]*?\}\s*\{[\s\S]*?\}\s*/g, '');
                            displayContent = displayContent.replace(/^\s*\{[\s\S]*?\}\s*/g, '');
                            
                            if (displayContent.includes('"search_queries"') || 
                                displayContent.includes('"research_plan"') || 
                                displayContent.includes('"score"')) {
                                displayContent = displayContent.replace(/\{[\s\S]*?\}/g, function(match) {
                                    if (match.includes('"search_queries"') || 
                                        match.includes('"research_plan"') || 
                                        match.includes('"score"') ||
                                        match.includes('"priority"') ||
                                        match.includes('"is_sufficient"') ||
                                        match.includes('"feedback"')) {
                                        return '';
                                    }
                                    return match;
                                }).trim();
                            }
                            
                            hasReceivedToken = true;
                            const formattedContent = formatMessage(displayContent);
                            bubble.innerHTML = formattedContent + '<span class="streaming-cursor">â–Š</span>';
                            messagesContainer.scrollTop = messagesContainer.scrollHeight;
                        } else if (data.type === 'content') {
                            fullContent += data.content;
                            hasReceivedToken = true;
                            const formattedContent = formatMessage(fullContent);
                            bubble.innerHTML = formattedContent + '<span class="streaming-cursor">â–Š</span>';
                            messagesContainer.scrollTop = messagesContainer.scrollHeight;
                        } else if (data.type === 'node') {
                            const nodeName = data.node || '';
                            const displayName = data.display || '';
                            
                            const searchInfo = nodeSearchInfo[nodeName] || {};
                            const stepIndex = addOrUpdateThinkingStep(nodeName, displayName, searchInfo);
                            
                            if (stepIndex !== -1) {
                                shouldShowThinkingProcess = true;
                                updateThinkingProcessUI();
                            }
                            
                            if (nodeName && ['writer', 'faq_specialist', 'transaction_specialist', 'intent_clarifier', 'simple_chat_specialist'].includes(nodeName)) {
                                currentResponseNode = nodeName;
                            }
                            
                            if (!hasReceivedToken && (!fullContent || fullContent.trim() === '')) {
                                bubble.innerHTML = `<span class="node-status">${displayName}</span><span class="streaming-cursor">â–Š</span>`;
                                messagesContainer.scrollTop = messagesContainer.scrollHeight;
                            }
                        } else if (data.type === 'node_search') {
                            const nodeName = data.node || '';
                            const searchInfo = data.search_info || {};
                            
                            if (nodeName === 'simple_chat_specialist' || nodeName === 'transaction_specialist') {
                                return;
                            }
                            
                            nodeSearchInfo[nodeName] = searchInfo;
                            
                            const nodeDisplay = nodeHistory.find(n => n.name === nodeName)?.display || NODE_DISPLAY_NAMES[nodeName] || nodeName;
                            const stepIndex = addOrUpdateThinkingStep(nodeName, nodeDisplay, searchInfo);
                            
                            if (stepIndex !== -1) {
                                shouldShowThinkingProcess = true;
                                updateThinkingProcessUI();
                            }
                        } else if (data.type === 'done') {
                            let finalText = fullContent || data.final_response || '';
                            
                            jsonBlocks.forEach(jsonBlock => {
                                finalText = finalText.replace(jsonBlock.text, '').trim();
                            });
                            finalText = finalText.replace(/^\s*\{[\s\S]*?\}\s*\{[\s\S]*?\}\s*/g, '');
                            finalText = finalText.replace(/^\s*\{[\s\S]*?\}\s*/g, '');
                            
                            const formattedContent = formatMessage(finalText);
                            bubble.innerHTML = formattedContent;
                            
                            if (currentResponseNode === 'simple_chat_specialist' || currentResponseNode === 'transaction_specialist') {
                                shouldShowThinkingProcess = false;
                            } else {
                                const filteredNodeSearchInfo = Object.fromEntries(
                                    Object.entries(nodeSearchInfo).filter(([nodeName]) => 
                                        nodeName !== 'simple_chat_specialist' && nodeName !== 'transaction_specialist'
                                    )
                                );
                                
                                if (thinkingSteps.length > 0 || Object.keys(filteredNodeSearchInfo).length > 0) {
                                    shouldShowThinkingProcess = true;
                                    
                                    if (!thinkingProcessUI && thinkingSteps.length > 0) {
                                        thinkingProcessUI = createThinkingProcessUI(thinkingSteps);
                                    } else if (thinkingProcessUI) {
                                        updateThinkingProcessUI();
                                    }
                                    
                                    if (thinkingProcessUI && !messageDiv.contains(thinkingProcessUI)) {
                                        messageDiv.appendChild(thinkingProcessUI);
                                    }
                                    
                                    if (thinkingProcessUI) {
                                        thinkingProcessUI.classList.add('collapsed');
                                        thinkingProcessUI.classList.remove('expanded');
                                    }
                                }
                            }
                            
                            sendBtn.disabled = false;
                        } else if (data.type === 'error') {
                            bubble.innerHTML = formatMessage('ì£„ì†¡í•©ë‹ˆë‹¤. ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ' + data.content);
                            sendBtn.disabled = false;
                        }
                    } catch (parseError) {
                        console.error('SSE íŒŒì‹± ì˜¤ë¥˜:', parseError);
                    }
                }
            }
        }
        
        let finalContent = fullContent;
        jsonBlocks.forEach(jsonBlock => {
            finalContent = finalContent.replace(jsonBlock.text, '').trim();
        });
        finalContent = finalContent.replace(/^\s*\{[\s\S]*?\}\s*\{[\s\S]*?\}\s*/g, '');
        finalContent = finalContent.replace(/^\s*\{[\s\S]*?\}\s*/g, '');
        
        const finalFormattedContent = formatMessage(finalContent);
        bubble.innerHTML = finalFormattedContent;
        
        if (currentResponseNode === 'simple_chat_specialist' || currentResponseNode === 'transaction_specialist') {
            shouldShowThinkingProcess = false;
        } else {
            const filteredNodeSearchInfo = Object.fromEntries(
                Object.entries(nodeSearchInfo).filter(([nodeName]) => 
                    nodeName !== 'simple_chat_specialist' && nodeName !== 'transaction_specialist'
                )
            );
            
            if (thinkingSteps.length > 0 || Object.keys(filteredNodeSearchInfo).length > 0) {
                shouldShowThinkingProcess = true;
                
                if (!thinkingProcessUI && thinkingSteps.length > 0) {
                    thinkingProcessUI = createThinkingProcessUI(thinkingSteps);
                } else if (thinkingProcessUI) {
                    updateThinkingProcessUI();
                }
                
                if (thinkingProcessUI && !messageDiv.contains(thinkingProcessUI)) {
                    messageDiv.appendChild(thinkingProcessUI);
                }
                
                if (thinkingProcessUI) {
                    thinkingProcessUI.classList.add('collapsed');
                    thinkingProcessUI.classList.remove('expanded');
                }
            }
        }
        
        sendBtn.disabled = false;
        
    } catch (error) {
        if (error.name === 'AbortError') {
            console.log('ìš”ì²­ì´ ì·¨ì†Œë˜ì—ˆìŠµë‹ˆë‹¤.');
        } else {
            console.error('ìŠ¤íŠ¸ë¦¬ë° ì˜¤ë¥˜:', error);
            bubble.innerHTML = formatMessage('ì—°ê²° ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.');
        }
        sendBtn.disabled = false;
    }
}

async function sendMessageNormal(message, sendBtn) {
    const loadingId = showLoading();
    
    try {
        const response = await fetch('/api/chat', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                message: message,
                session_id: sessionId
            }),
            signal: currentAbortController.signal
        });
        
        const data = await response.json();
        
        hideLoading(loadingId);
        sendBtn.disabled = false;
        
        if (data.error) {
            addMessageToChat('assistant', 'ì£„ì†¡í•©ë‹ˆë‹¤. ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ' + data.error);
        } else {
            addMessageToChat('assistant', data.response);
        }
        
    } catch (error) {
        hideLoading(loadingId);
        sendBtn.disabled = false;
        if (error.name !== 'AbortError') {
            addMessageToChat('assistant', 'ì—°ê²° ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.');
            console.error('Error:', error);
        }
    }
}

function addMessageToChat(role, content, scroll = true) {
    const messagesContainer = document.getElementById('chatMessages');
    
    const emptyState = messagesContainer.querySelector('.empty-state');
    if (emptyState) {
        emptyState.remove();
    }
    
    const messageDiv = document.createElement('div');
    messageDiv.className = `message ${role}`;
    
    const bubble = document.createElement('div');
    bubble.className = 'message-bubble';
    
    const formattedContent = formatMessage(content);
    bubble.innerHTML = formattedContent;
    
    messageDiv.appendChild(bubble);
    messagesContainer.appendChild(messageDiv);
    
    if (scroll) {
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
    }
}

function formatMessage(text) {
    if (!text) return '';
    
    // ì½”ë“œ ë¸”ë¡ ë¨¼ì € ì²˜ë¦¬
    const codeBlocks = [];
    let codeBlockIndex = 0;
    text = text.replace(/```([\s\S]*?)```/g, (match, code) => {
        const placeholder = `__CODE_BLOCK_${codeBlockIndex}__`;
        codeBlocks[codeBlockIndex] = code;
        codeBlockIndex++;
        return placeholder;
    });
    
    // ë²ˆí˜¸ ë¦¬ìŠ¤íŠ¸ ì²˜ë¦¬
    text = text.replace(/((?:^\s*\d+\.\s+.+?(?:\n|$))+)/gm, (match) => {
        const lines = match.split('\n');
        const items = [];
        
        for (const line of lines) {
            const trimmed = line.trim();
            if (!trimmed) continue;
            
            const numberedMatch = trimmed.match(/^\d+\.\s+(.+)$/);
            if (numberedMatch) {
                items.push(numberedMatch[1]);
            }
        }
        
        if (items.length > 0) {
            return '<ol>' + items.map(item => `<li>${item}</li>`).join('') + '</ol>';
        }
        return match;
    });
    
    // ë¶ˆë¦¿ í¬ì¸íŠ¸ ë¦¬ìŠ¤íŠ¸ ì²˜ë¦¬
    text = text.replace(/((?:^[-â€¢]\s+.+$(?:\n|$))+)/gm, (match) => {
        const lines = match.trim().split('\n');
        const items = [];
        
        for (const line of lines) {
            const trimmed = line.trim();
            const bulletMatch = trimmed.match(/^[-â€¢]\s+(.+)$/);
            if (bulletMatch) {
                items.push(bulletMatch[1]);
            }
        }
        
        if (items.length > 0) {
            return '<ul>' + items.map(item => `<li>${item}</li>`).join('') + '</ul>';
        }
        return match;
    });
    
    let html = text;
    
    // HTML íƒœê·¸ ë³´í˜¸
    const htmlPlaceholders = [];
    let placeholderIndex = 0;
    html = html.replace(/(<[^>]+>)/g, (match) => {
        const placeholder = `__HTML_TAG_${placeholderIndex}__`;
        htmlPlaceholders[placeholderIndex] = match;
        placeholderIndex++;
        return placeholder;
    });
    
    // HTML ì´ìŠ¤ì¼€ì´í”„
    html = html
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;');
    
    // ì¤„ë°”ê¿ˆ ì²˜ë¦¬
    html = html.replace(/\n/g, '<br>');
    
    // HTML íƒœê·¸ ë³µì›
    htmlPlaceholders.forEach((tag, index) => {
        html = html.replace(`__HTML_TAG_${index}__`, tag);
    });
    
    // ì½”ë“œ ë¸”ë¡ ë³µì›
    codeBlocks.forEach((code, index) => {
        const escapedCode = code
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;');
        html = html.replace(`__CODE_BLOCK_${index}__`, `<pre><code>${escapedCode}</code></pre>`);
    });
    
    // ì¸ë¼ì¸ ì½”ë“œ ì²˜ë¦¬
    html = html.replace(/`([^`\n]+)`/g, '<code>$1</code>');
    
    // ê°•ì¡° í‘œì‹œ
    html = html.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');
    
    // ë§í¬ ë³€í™˜
    html = html.replace(
        /(https?:\/\/[^\s<>\)]+)/g,
        (match) => {
            let fixedUrl = match
                .replace(/xn--com[^\/]*/gi, 'com')
                .replace(/\)[^\/]*/g, '')
                .replace(/[^\/]$/, '');
            
            if (fixedUrl.includes('bithumb')) {
                if (fixedUrl.includes('support.bithumb')) {
                    fixedUrl = 'https://support.bithumb.com/hc/ko';
                } else if (fixedUrl.includes('www.bithumb') || fixedUrl.includes('bithumb.com')) {
                    fixedUrl = 'https://www.bithumb.com';
                }
            }
            
            return `<a href="${fixedUrl}" target="_blank" rel="noopener noreferrer">${fixedUrl}</a>`;
        }
    );
    
    // ì—°ì†ëœ <br>ë¥¼ ë‹¨ë½ êµ¬ë¶„ìœ¼ë¡œ ë³€í™˜
    html = html.replace(/(<br>\s*){2,}(?![^<]*<\/[ou]l>)/g, '</p><p>');
    html = '<p>' + html + '</p>';
    html = html.replace(/<p>\s*<\/p>/g, '');
    html = html.replace(/<p>(<pre>)/g, '$1');
    html = html.replace(/(<\/pre>)<\/p>/g, '$1');
    html = html.replace(/<p>(<[ou]l>)/g, '$1');
    html = html.replace(/(<\/[ou]l>)<\/p>/g, '$1');
    
    return html;
}

function showLoading() {
    const messagesContainer = document.getElementById('chatMessages');
    const loadingDiv = document.createElement('div');
    loadingDiv.className = 'message assistant';
    loadingDiv.id = 'loadingMessage';
    
    const bubble = document.createElement('div');
    bubble.className = 'message-bubble loading';
    bubble.innerHTML = `
        <div class="loading-dot"></div>
        <div class="loading-dot"></div>
        <div class="loading-dot"></div>
    `;
    
    loadingDiv.appendChild(bubble);
    messagesContainer.appendChild(loadingDiv);
    messagesContainer.scrollTop = messagesContainer.scrollHeight;
    
    return 'loadingMessage';
}

function hideLoading(loadingId) {
    const loading = document.getElementById(loadingId);
    if (loading) {
        loading.remove();
    }
}

async function clearChat() {
    if (!confirm('ëŒ€í™” ê¸°ë¡ì„ ëª¨ë‘ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) {
        return;
    }
    
    try {
        const response = await fetch(`/api/chat/history/${sessionId}`, {
            method: 'DELETE'
        });
        
        const data = await response.json();
        
        if (data.success) {
            const messagesContainer = document.getElementById('chatMessages');
            messagesContainer.innerHTML = `
                <div class="empty-state">
                    <h2>ì•ˆë…•í•˜ì„¸ìš”! ğŸ‘‹</h2>
                    <p>ë¸”ë¡ì²´ì¸ê³¼ ë¹—ì¸ ê±°ë˜ì†Œì— ê´€ë ¨ëœ ì§ˆë¬¸ì„ í•´ì£¼ì„¸ìš”.</p>
                    <p style="margin-top: var(--space-md); font-size: var(--font-size-sm);">
                        íŠ¸ëœì­ì…˜ ì¡°íšŒ, FAQ ê²€ìƒ‰, ë¸”ë¡ì²´ì¸ ì •ë³´ ë“± ë¬´ì—‡ì´ë“  ë¬¼ì–´ë³´ì„¸ìš”.
                    </p>
                </div>
            `;
        }
    } catch (error) {
        console.error('ëŒ€í™” ê¸°ë¡ ì‚­ì œ ì‹¤íŒ¨:', error);
        alert('ëŒ€í™” ê¸°ë¡ ì‚­ì œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
    }
}
</script>
{% endblock %}
